---
title: "Anshi work"
author: "Anshi Arora"
date: "2024-10-29"
output: html_document
---
# Question 1
---
What do you imagine is the reason for log-transforming the protein levels in biomarker-raw.csv? (Hint: look at the distribution of raw values for a sample of proteins.)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '~/Downloads/module1-group-10/data')
setwd("~/Downloads/module1-group-10/data")
biomarker_raw<-read.csv("biomarker-raw.csv")
```

### Sampled 5 proteins from the raw dataset and isolated their protein levels
```{r}
set.seed(1045)
protein_numbers <- sample(3:ncol(biomarker_raw), size = 5, replace=F)
protein_sample <- biomarker_raw[,protein_numbers]
colnames(protein_sample) <- protein_sample[1,]
protein_sample <- protein_sample[-1,]
```

The proteins sampled were PGRP-S, PACAP-27, TRAIL R4, IGFBP-1, cIAP-2. 

### Distributions of the protein levels for these 5 proteins is shown below
```{r, echo=FALSE, message=False}
library(ggplot2)
library(tidyverse)
```

```{r}
protein_sample2 <- protein_sample %>% pivot_longer(cols = everything(), names_to = "protein", values_to = "level")
protein_sample2$level <- as.numeric(protein_sample2$level)
protein_sample2 %>% ggplot() + geom_histogram(aes(x = level), bins = 50) + facet_wrap("protein") + xlim(0,8000)
```
As we can see, the distributions do not seem normal as many of them are skewed to the left and do not seem centered around a mean. We can use qqplots for each of these proteins to support this conclusion. 

```{r, warning = F}
protein_sample2 %>% ggplot(aes(sample = level)) + stat_qq() + stat_qq_line(color = "red") + facet_wrap("protein") + ylim(0, 10000)
```
As shown above, a lot of the protein level distributions for our sample of 5 proteins do not follow the qqline shown in red for each above qq-plot. To determine if they significantly stray away from a normal distribution, we can use Shapiro-Wilk Tests.

```{r}
protein_sample2 %>% group_by(protein) %>% summarise("pval" = shapiro.test(as.numeric(level))$p.value) %>% mutate("normal" = ifelse(pval < 0.05, FALSE, TRUE))
```
The tests with p-values smaller than our alpha of 0.05 indicate that we should reject the null hypothesis that the distributions of the levels for these proteins is normal. As shown above, all proteins failed the normality test. 

This is why the log transformation is required. Below, we once again generate distribution histograms and qq-plots for each protein. However, this time we use the log transformed data for these proteins from the biomarker_clean dataset.

```{r}
log_protein_sample <- biomarker_clean %>% select("PGRP-S", "PACAP-27", "TRAIL R4", "IGFBP-1", "cIAP-2") %>% pivot_longer(cols = everything(), names_to = "protein", values_to = "level")
log_protein_sample$level <- as.numeric(log_protein_sample$level)
log_protein_sample %>% ggplot() + geom_histogram(aes(x = level), bins = 50) + facet_wrap("protein")
```

As we can see above, compared to the original protein level distributions for these proteins, the distributions look much closer to the normal distribution 

```{r}
log_protein_sample %>% ggplot(aes(sample = level)) + stat_qq() + stat_qq_line(color = "red") + facet_wrap("protein")
```
The qq-plots look much more representative of normal distributions after the log transformation. 

```{r, echo = F, message = F, warning=FALSE}
library(infer)
library(randomForest)
library(tidymodels)
library(modelr)
library(yardstick)
```

# Question 3: Experiment with the following modifications:

-repeat the analysis but carry out the entire selection procedure on a training partition -- in other words, set aside some testing data at the very beginning and don't use it until you are evaluating accuracy at the very end.

```{r}
trim <- function(x, .at){
  x[abs(x) > .at] <- sign(x[abs(x) > .at])*.at
  return(x)
}

var_names <- read_csv("biomarker-raw.csv", col_names = F, n_max = 2, col_select = -(1:2)) %>%
  t() %>%
  as_tibble() %>%
  rename(name = V1, abbreviation = V2) %>%
  na.omit()

biomarker_data <- read_csv("biomarker-raw.csv", skip = 2, col_select = -2L,
                           col_names = c('group', 'empty', pull(var_names, abbreviation), 'ados'),
                           na = c('-', '')) %>%
  filter(!is.na(group)) %>%
  mutate(across(.cols = -c(group, ados), ~ trim(scale(log10(.x))[, 1], .at = 3))) %>%
  select(group, ados, everything())

set.seed(101422)
biomarker_split <- initial_split(biomarker_data, prop = 0.8)
biomarker_train <- training(biomarker_split)
biomarker_test <- testing(biomarker_split)
```
How are the results affected by this modification: By setting aside testing data at the start, we ensure that the evaluation is more accurate and unbiased, as the model and feature selection are based solely on the training data.

-choose a larger number (more than ten) of top predictive proteins using each selection method

For both the t-test and random forest selection methods, I used the top 20 proteins based on their significance or importance scores.

```{r}
proteins_s1 <- ttests_out %>%
  slice_min(p.adj, n = 20) %>%
  pull(protein)
predictors <- biomarker_train %>% select(-c(group, ados))
response <- biomarker_train %>% pull(group) %>% factor()

set.seed(101422)
rf_out <- randomForest(x = predictors, y = response, ntree = 1000, importance = TRUE)

proteins_s2 <- rf_out$importance %>% 
  as_tibble() %>%
  mutate(protein = rownames(rf_out$importance)) %>%
  slice_max(MeanDecreaseGini, n = 20) %>%
  pull(protein)
```

How are the results affected by this modification: Increasing the number of proteins used as features can allow the model to capture more variance in the data, which may improve the predictive accuracy.

-use a fuzzy intersection instead of a hard intersection to combine the sets of top predictive proteins across selection methods

```{r}
protein_union <- union(proteins_s1, proteins_s2)
ranked_proteins <- tibble(
  protein = protein_union,
  rank_s1 = match(protein_union, proteins_s1, nomatch = 21),
  rank_s2 = match(protein_union, proteins_s2, nomatch = 21)
) %>%
  mutate(total_rank = rowMeans(across(starts_with("rank")), na.rm = TRUE)) %>%
  arrange(total_rank) %>%
  slice_min(total_rank, n = 20) %>%
  pull(protein)
```

How are the results affected by this modification: This increases flexibility by allowing proteins that are significant in only one method but rank highly to contribute to the model.